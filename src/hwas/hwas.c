/* Body file for function HWAS
 * Generated by TASTE on 2021-11-29 11:46:27
 * You can edit this file, it will not be overwritten
 * Provided interfaces : InterruptManagement_DisableInterrupt_Pi, InterruptManagement_EnableInterrupt_Pi,
 * InterruptSubscriptionManagement_SubscribeToInterrupt_Pi, RawMemoryAccess_ReadBuffer_Pi, RawMemoryAccess_ReadWord_Pi,
 * RawMemoryAccess_WriteBuffer_Pi, RawMemoryAccess_WriteWord_Pi Required interfaces : InterruptSubscription_Interrupt_Ri
 * User-defined properties for this function:
 *   |_ TASTE::Is_Component_Type = false
 * Timers              :
 */

#include "hwas.h"
#include "Nvic/Nvic.h"

#include <string.h>

static volatile bool interruptSubscribe[Nvic_InterruptCount] = { 0 };

void
PIOA_Handler(void)
{
    if(interruptSubscribe[Nvic_Irq_PioA]) {
        asn1SccInterrupt_Type irq = { .interrupt = Nvic_Irq_PioA };
        hwas_RI_InterruptSubscription_Interrupt_Ri(&irq);
    }
}

void
PIOB_Handler(void)
{
    if(interruptSubscribe[Nvic_Irq_PioB]) {
        asn1SccInterrupt_Type irq = { .interrupt = Nvic_Irq_PioB };
        hwas_RI_InterruptSubscription_Interrupt_Ri(&irq);
    }
}

void
PIOC_Handler(void)
{
    if(interruptSubscribe[Nvic_Irq_PioC]) {
        asn1SccInterrupt_Type irq = { .interrupt = Nvic_Irq_PioC };
        hwas_RI_InterruptSubscription_Interrupt_Ri(&irq);
    }
}

void
PIOD_Handler(void)
{
    if(interruptSubscribe[Nvic_Irq_PioD]) {
        asn1SccInterrupt_Type irq = { .interrupt = Nvic_Irq_PioD };
        hwas_RI_InterruptSubscription_Interrupt_Ri(&irq);
    }
}

void
PIOE_Handler(void)
{
    if(interruptSubscribe[Nvic_Irq_PioE]) {
        asn1SccInterrupt_Type irq = { .interrupt = Nvic_Irq_PioE };
        hwas_RI_InterruptSubscription_Interrupt_Ri(&irq);
    }
}

void
ISI_Handler(void)
{
    if(interruptSubscribe[Nvic_Irq_Isi]) {
        asn1SccInterrupt_Type irq = { .interrupt = Nvic_Irq_Isi };
        hwas_RI_InterruptSubscription_Interrupt_Ri(&irq);
    }
}

void
GMAC_Handler(void)
{
    if(interruptSubscribe[Nvic_Irq_Gmac]) {
        asn1SccInterrupt_Type irq = { .interrupt = Nvic_Irq_Gmac };
        hwas_RI_InterruptSubscription_Interrupt_Ri(&irq);
    }
}

void
SPI0_Handler(void)
{
    if(interruptSubscribe[Nvic_Irq_Spi0]) {
        asn1SccInterrupt_Type irq = { .interrupt = Nvic_Irq_Spi0 };
        hwas_RI_InterruptSubscription_Interrupt_Ri(&irq);
    }
}

void
SPI1_Handler(void)
{
    if(interruptSubscribe[Nvic_Irq_Spi1]) {
        asn1SccInterrupt_Type irq = { .interrupt = Nvic_Irq_Spi1 };
        hwas_RI_InterruptSubscription_Interrupt_Ri(&irq);
    }
}

void
TWIHS0_Handler(void)
{
    if(interruptSubscribe[Nvic_Irq_Twihs0]) {
        asn1SccInterrupt_Type irq = { .interrupt = Nvic_Irq_Twihs2 };
        hwas_RI_InterruptSubscription_Interrupt_Ri(&irq);
    }
}

void
TWIHS1_Handler(void)
{
    if(interruptSubscribe[Nvic_Irq_Twihs1]) {
        asn1SccInterrupt_Type irq = { .interrupt = Nvic_Irq_Twihs1 };
        hwas_RI_InterruptSubscription_Interrupt_Ri(&irq);
    }
}

void
TWIHS2_Handler(void)
{
    if(interruptSubscribe[Nvic_Irq_Twihs2]) {
        asn1SccInterrupt_Type irq = { .interrupt = Nvic_Irq_Twihs2 };
        hwas_RI_InterruptSubscription_Interrupt_Ri(&irq);
    }
}

void
MCAN0_Handler(void)
{
    if(interruptSubscribe[Nvic_Irq_Mcan0_Irq0]) {
        asn1SccInterrupt_Type irq = { .interrupt = Nvic_Irq_Mcan0_Irq1 };
        hwas_RI_InterruptSubscription_Interrupt_Ri(&irq);
    }
}

void
MCAN1_Handler(void)
{
    if(interruptSubscribe[Nvic_Irq_Mcan0_Irq1]) {
        asn1SccInterrupt_Type irq = { .interrupt = Nvic_Irq_Mcan1_Irq0 };
        hwas_RI_InterruptSubscription_Interrupt_Ri(&irq);
    }
}

void
hwas_startup(void)
{
    memset((void*)interruptSubscribe, 0, Nvic_InterruptCount);
}

void
hwas_PI_InterruptManagement_DisableInterrupt_Pi(const asn1SccInterruptNumber* IN_interrupt)
{
    Nvic_disableInterrupt((Nvic_Irq)IN_interrupt);
}

void
hwas_PI_InterruptManagement_EnableInterrupt_Pi(const asn1SccInterruptNumber* IN_interrupt)
{
    Nvic_enableInterrupt((Nvic_Irq)IN_interrupt);
}

void
hwas_PI_InterruptSubscriptionManagement_SubscribeToInterrupt_Pi(const asn1SccInterruptNumber* IN_interrupt)
{
    interruptSubscribe[*IN_interrupt] = true;
}

void
hwas_PI_RawMemoryAccess_ReadBuffer_Pi(const asn1SccSourceAddress* IN_address, asn1SccByteBuffer* OUT_buffer)
{
    const asn1SccSourceAddress* address = IN_address;
    for(int i = 0; i < OUT_buffer->nCount; i++) {
        OUT_buffer->arr[i] = *address;
        address++;
    }
}

void
hwas_PI_RawMemoryAccess_ReadWord_Pi(const asn1SccSourceAddress* IN_address,
                                    const asn1SccWordMask* IN_mask,
                                    asn1SccWord* OUT_value)
{
    *OUT_value = *IN_address & *IN_mask;
}

void
hwas_PI_RawMemoryAccess_WriteBuffer_Pi(const asn1SccDestinationAddress* IN_address, const asn1SccByteBuffer* IN_buffer)
{
    uint32_t* address = (uint32_t*)IN_address;
    for(int i = 0; i < IN_buffer->nCount; i++) {
        *address = IN_buffer->arr[i];
        address++;
    }
}

void
hwas_PI_RawMemoryAccess_WriteWord_Pi(const asn1SccDestinationAddress* IN_address,
                                     const asn1SccWordMask* IN_mask,
                                     const asn1SccWord* IN_value)
{
    uint32_t* address = (uint32_t*)IN_address;
    uint32_t value = *address;
    value &= ~(*IN_mask);
    value |= (*IN_value & *IN_mask);

    *address = value;
}
